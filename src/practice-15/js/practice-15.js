//! Імперативний код
//? ✴️ Описує процес обчислення у вигляді
//? заданої послідовності інструкцій,
//? що змінюють стан програми.
//? Опис того, як щось виконується.
//? ✳️ Імперативний стиль програмування - це такий стиль,
//? що надає машині набір детальних інструкцій для виконання задачі.
//? Наприклад, цикл for, який надає точні вказівки
//? для ітерації по індексам масиву.
//? ✳️ Можна провести аналогію з рецептом приготування страви. 
//? Рецепт - це набір покрокових інструкцій 
//? для отримання бажаного результату.
console.warn(`Приклад «Імперативного коду»: \n ${((window.location.href).split('/')).slice(0, -2).join('/') + '/'}${"lesson-FE3_14/images/imperative-programming-example.jpg"}`);

//todo: Приклади Імперативного коду
console.warn("Приклад-1. Імперативний код:");
const book = {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    genres: ["historical prose", "adventure"],
    isPublic: true,
    rating: 8.38,
};
console.log("book:", book);

//todo: Приклад-1. Імперативний код:
console.log(
    `%c
                                                             
        const title = "The Last Kingdom";                    
        const author = "Bernard Cornwell";                   
        const genres = ["historical prose", "adventure"];    
        const isPublic = true;                               
        const rating = 8.38;                                 
                                                             `,
    'color: #ffff60; background-color: #ff7272',
);
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");


console.warn("Приклад-2. Імперативний код:");
//todo: Приклад-2. Імперативний код:
//? Напиши скрипт підрахунку вартості гравіювання прикрас.
//? Для цього створи функцію
//? calculateEngravingPrice(message, pricePerWord)
//? приймаючу рядок (в рядку будуть тільки слова і прогалини)
//? і ціну гравіювання одного слова,
//? і повертає ціну гравіювання всіх слів в рядку.
console.log(
    `%c
                                                                      
        function calculateEngravingPrice(message, pricePerWord) {     
                                                                      
            let words = 0;                                            
            let inWord = false;                                       
                                                                      
            for (const character of message.trim()) {                 
                if (character !== ' ' && !inWord) {                   
                    words++;                                          
                    inWord = true;                                    
                } else if (character === ' ') {                       
                    inWord = false;                                   
                };                                                    
            };                                                        
                                                                      
            return words * pricePerWord;                              
        };                                                            
                                                                      `,
    'color: #ffff60; background-color: #00c1cf',
);

function calculateEngravingPrice(message, pricePerWord) {

    let words = 0;
    let inWord = false;

    for (const character of message) {
        if (character !== ' ' && !inWord) {
            words++;
            inWord = true;
        } else if (character === ' ') {
            inWord = false;
        };
    };

    return words * pricePerWord;
};


console.log("Price:", calculateEngravingPrice("Той, хто задоволений самим собою – багач", 10)); //! 70
console.log("-----------------------------------------------------------------------------------------------------------");


//! Декларативний код
//? ✴️ Описує те, що ми хочемо отримати у підсумку,
//? а не спосіб це зробити.
//? Порядок виконання і спосіб досягнення - неважливі.
//? ✳️ Коли ми пишемо HTML-код, то декларативно,
//? за допомогою тегів та атрибутів, описуємо те,
//? що хочемо отримати у підсумку.
//? Браузер читає цей код і сам виконує всі необхідні операції
//? для створення HTML-елементів і розміщення їх на сторінці.
//? ✳️ Можна провести аналогію з меню ресторану.
//? Це декларативний набір страв, які можна замовити,
//? подробиці приготування і подачі яких приховані.
console.warn(`Приклад «Декларативного коду»: \n ${((window.location.href).split('/')).slice(0, -2).join('/') + '/'}${"lesson-FE3_14/images/declarative-programming-example.jpg"}`);

//todo: Приклади Декларативного коду
console.warn("Приклад-1. Декларативний код:");
console.log(
    `%c
                                                                            
    const { title, author, genres, isPublic, rating, coverImage } = book;   
                                                                            `,
    'color: #21ff21; background-color: #ff7272',
);
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");


console.warn("Приклад-2. Декларативний код:");
//todo: Приклад-2. Декларативний код:
console.log(
    `%c
                                                                      
        function calculateEngravingPrice(message, pricePerWord) {     
            return message.split(" ").length * pricePerWord;          
        };                                                            
                                                                      `,
    'color: #9bff9b; background-color: #00c1cf',
);

function calculateEngravingPrice2(message, pricePerWord) {
    return message.split(" ").length * pricePerWord;
};
console.log("Price:", calculateEngravingPrice2("Той, хто задоволений самим собою – багач", 10)); //! 70
console.log("-----------------------------------------------------------------------------------------------------------");

//! Функція з побічними ефектами
console.warn("Функція з побічними ефектами:")
//? ✴️ Функція з побічними ефектами - це функція,
//? яка в процесі виконання може змінювати
//? або використовувати глобальні змінні,
//? змінювати значення аргументів посилального типу,
//? виконувати операції введення-виведення тощо.
//? ✳️ Функція dirtyMultiply(array, value) множить 
//? кожен елемент масиву array на число value. 
//? Вона змінює (мутує) вихідний масив за посиланням.
const dirtyMultiply = (array, value) => {
    for (let i = 0; i < array.length; i += 1) {
        array[i] = array[i] * value;
    };
};

const numbers = [1, 2, 3, 4, 5];
console.log("numbers_before:", numbers); //! [1, 2, 3, 4, 5]

dirtyMultiply(numbers, 2);

//todo: Відбулася мутація вихідних даних - масиву numbers:
console.log("numbers_after:", numbers); //! [2, 4, 6, 8, 10]
console.log(". . . . . . . . . . . . . . . . . . . .");



//! Чиста функція
console.warn("Чиста функція:");
//? ✴️ Чиста функція (pure function) - це функція,
//? результат якої залежить тільки від
//? значень переданих аргументів.
//? За умови однакових аргументів вона
//? завжди повертає один і той самий результат
//? і не має побічних ефектів,
//? тобто не змінює значення аргументів.
//? ✳️ Напишемо реалізацію чистої функції 
//? множення елементів масиву, 
//? що повертає новий масив, не змінюючи вихідний.
const pureMultiply = (array, value) => {
    const newArray1 = [];
    const newArray2 = [];

    //todo: var.1
    for (let i = 0; i < array.length; i += 1) {
        newArray1.push(array[i] * value);
    };

    //todo: var.2
    array.forEach(element => {
        newArray2.push(element * value);
    });

    // return newArray1;
    // return newArray2;
    return {
        newArray1,
        newArray2
    };
};

const numbers2 = [1, 2, 3, 4, 5];
console.log("numbers2_before:", numbers2); //! [1, 2, 3, 4, 5]

const doubledNumbers = pureMultiply(numbers2, 2);

//todo: Мутація вихідних даних - масиву numbers2 не відбулася:
console.log("numbers2_after:", numbers2); //! [1, 2, 3, 4, 5]

//todo: Функція повернула новий масив зі зміненими даними:
console.log("doubledNumbers:", doubledNumbers); //! [2, 4, 6, 8, 10]
console.log("---------------------------------------");
//! 4.Метод forEach
console.warn("Синтаксис методу forEach:");
//? ✴️ Метод перебирання масиву,
//? який використовується для заміни циклів
//? for і for...of в роботі з колекцією даних.
//? 🔸 Поелементно перебирає масив.
//? 🔸 Викликає колбек-функцію для кожного елемента масиву.
//? 🔸 Нічого не повертає.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.forEach(function callback(element, index, array) {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);


//? ✳️ Можна оголошувати тільки необхідні параметри,
//? найчастіше - це елемент, головне не забувати про їх порядок.
const numbers1 = [5, 10, 15, 20, 25];
console.log("numbers:", numbers);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `");

console.warn("Функціональний forEach:");
//todo: Функціональний forEach:
numbers1.forEach(num => console.log(num));
// const forEach = numbers1.forEach(num => console.log(num));
// console.log("forEach",forEach); //! undefiend
console.log(". . . . . . . . . . . .");

console.warn("Перебирання за допомогою Класичного for:");
//todo: Перебирання за допомогою Класичного for:
for (let i = 0; i < numbers1.length; i += 1) {
    console.log(`Індекс: ${i}, значення: ${numbers1[i]}`);
};
console.log(". . . . . . . . . . . .");

console.warn("Метод перебирання forEach (var.1):");
//todo: Метод перебирання forEach (var.1):
numbers.forEach(function (number, index) {
    console.log(`Індекс: ${index}, значення: ${number}`);
});
console.log(". . . . . . . . . . . .");

console.warn("Метод перебирання forEach (var.2):");
//todo: Метод перебирання forEach (var.2):
numbers.forEach((num, idx) => console.log(`index: ${idx}, value: ${num}`));
console.log("------------------------");

//? ❗️ Єдиним випадком, коли варто використовувати
//? цикли for або for...of для перебирання масиву,
//? - це задачі з перериванням виконання циклу.
//? ❗️❗️❗️ Перервати виконання методу forEach не можна,
//? він завжди перебирає масив до кінця.

//! Метод map()
console.warn("Синтаксис методу map():");
//? ✴️ Метод map(callback) використовується
//? для трансформації масиву.
//? Він викликає колбек-функцію
//? для кожного елемента вихідного масиву,
//? а результат її роботи записує у новий масив,
//? який і буде результатом виконання методу.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Результат роботи колбек-функції записується у новий масив.
//? 🔸 Повертає новий масив однакової довжини.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.map((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода map():");
//? ✳️ Його можна використовувати для того,
//? щоб змінити кожен елемент масиву.
//? Оригінальний масив використовується як еталон,
//? на основі якого можна зробити іншу колекцію.
const planets = ["Земля", "Марс", "Венера", "Юпітер"];
console.log("planets_before:", planets); //! ['Земля', 'Марс', 'Венера', 'Юпітер']

const planetsInUpperCase = planets.map(item => item.toUpperCase());
console.log("planetsInUpperCase:", planetsInUpperCase); //! ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПІТЕР']

const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
console.log("planetsInLowerCase:", planetsInLowerCase); //! ['земля', 'марс', 'венера', 'юпітер']

//todo: Оригінальний масив не змінився:
console.log("planets_after:", planets); //! ['Земля', 'Марс', 'Венера', 'Юпітер']
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .");

//! Масив об'єктів
console.warn("Масив об'єктів:");
//? ✳️ Ми вже знаємо, що повсякденне завдання
//? - це маніпуляція масивом об'єктів.
//? Наприклад, отримати масив значень властивості 
//? з усіх об'єктів. 
//? У нас є масив студентів, 
//? а потрібно отримати окремий масив їхніх імен.
const students1 = [
    { name: "Манго", score: 83 },
    { name: "Полі", score: 59 },
    { name: "Аякс", score: 37 },
    { name: "Ківі", score: 94 },
    { name: "Х'юстон", score: 64 },
];
console.log("students1:", students1);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");


const names = students1.map(student => student.name);
console.log("names:", names); //! ['Манго', 'Полі', 'Аякс', 'Ківі', 'Х'юстон']
const scores = students1.map(item => item.score);
console.log("scores", scores);
console.log("------------------------------------------------------------------");

//! Метод flatMap()
console.warn("Синтаксис методу flatMap():");
//? ✴️ Метод flatMap(callback)
//? - аналогічний методу map(),
//? але застосовується у випадках,
//? коли результат - це багатовимірний масив,
//? який необхідно «розгладити»,
//? тобто він розгортає вкладені масиви на один рівень
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Результат роботи колбек-функції записується у новий масив.
//? 🔸 Повертає новий розгладжений масив,
//?    який «розгладжується» на глибину,
//?    що дорівнює одиниці (одна вкладеність).
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.flatMap((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода flatMap():");
const students2 = [
    { name: "Манго", courses: ["математика", "фізика"] },
    { name: "Полі", courses: ["інформатика", "математика"] },
    { name: "Ківі", courses: ["фізика", "біологія"] },
];
console.log("students2:", students2);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

const coursesByMap = students2.map(student => student.courses);
console.log("coursesByMap:", coursesByMap); //! [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']]

const coursesByFlatMap = students2.flatMap(student => student.courses);
console.log("coursesByFlatMap:", coursesByFlatMap); //! ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];
console.log("------------------------------------------------------------------");

//! 6.Метод filter()
console.warn("Синтаксис методу filter():");
//? ✴️ Метод filter(callback) використовується
//? для єдиної операції - фільтрації масиву,
//? тобто, коли необхідно вибрати
//? більше одного елемента з колекції за певним критерієм.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає новий масив.
//? 🔸 Додає у масив, що повертається, елементи,
//?    які задовольняють умови колбек-функції.
//? 🔸 Якщо колбек повернув true,
//?    елемент додається у масив, що повертається.
//? 🔸 Якщо колбек повернув false,
//?    елемент не додається у масив, що повертається.
//? 🔸 Якщо жоден елемент не задовольнив умову,
//?     повертає порожній масив.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.filter((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода filter():");
//? ✳️ Метод filter() викликає колбек-функцію
//? для кожного елемента вихідного масиву і,
//? якщо результат її виконання - true,
//? додає поточний елемент у новий масив.
const values = [51, -3, 27, 21, -68, 42, -37];
console.log("values_before:", values); //! [51, -3, 27, 21, -68, 42, -37]

const positiveValues = values.filter(value => value >= 0);
console.log("positiveValues:", positiveValues); //! [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log("negativeValues:", negativeValues); //! [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log("bigValues:", bigValues); //! []

//todo: Оригінальний масив не змінився:
console.log("values_after:", values); //! [51, -3, 27, 21, -68, 42, -37]
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . .");

//! Фільтрація унікальних елементів​
console.warn("Фільтрація унікальних елементів:");
//? ✴️ Використовуючи метод filter(),
//? можна виконати фільтрацію масиву таким чином,
//? що у ньому залишаться тільки унікальні елементи.
//? Цей прийом працює тільки
//? з масивом примітивних значень - не з об'єктами.
//? ✳️ Повернемося до групи студентів
//? і масиву усіх відвідуваних предметів,
//? які ми отримали методом flatMap().
const students = [
    { name: "Манго", courses: ["математика", "фізика"] },
    { name: "Полі", courses: ["інформатика", "математика"] },
    { name: "Ківі", courses: ["фізика", "біологія"] },
];
console.log("students:", students);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

const allCoursesByMap = students.map(student => student.courses); // ❌
console.log("allCoursesByMap:", allCoursesByMap); //! [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']];

const allCourses = students.flatMap(student => student.courses); // ✅
console.log("allCourses:", allCourses); //! ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

//? ✳️ У змінній allCourses зберігається
//? масив усіх відвідуваних предметів,
//? які можуть повторюватися.
//? Завдання полягає у тому,
//? щоб створити новий масив,
//? в якому будуть тільки унікальні предмети,
//? тобто без повторень.
//? ❓❓❓ ЯК ЦЕ ПРАЦЮЄ:
//? 🟡 Для елемента 'математика' під індексом 0:
//?    ⏩ indexOf() поверне 0, тому що шукає перший збіг
//?    ⏩ Значення параметра index буде 0
//?    🟩 Вони рівні, а отже, це унікальний елемент
//? 🟡 Для елемента 'математика' під індексом 3:
//?    ⏩ indexOf() поверне 0, тому що шукає перший збіг
//?    ⏩ Значення параметра index буде 3
//?    🟥 Вони не рівні, а отже, це повторюваний - не унікальний елемент.
const uniqueCourses = allCourses.filter(
    (course, index, array) => array.indexOf(course) === index
);
console.log("Масив унікальних курсів:", uniqueCourses); //! ['математика', 'фізика', 'інформатика', 'біологія']
console.log("----------------------------------------------------------------------------------------------");

//! Масив об'єктів
console.warn("Масив об'єктів:");
//? ✴️ Під час роботи з масивом об'єктів виконується
//? фільтрація за значенням певної властивості.
//? У підсумку, утворюється новий масив відфільтрованих об'єктів.
//? ✳️ Наприклад, у нас є масив студентів з балами за тест.
//? Необхідно відфільтрувати:
//?  - кращих(бал вище 80),
//?  - середніх студентів(бал від 50 до 80) і,
//?  - гірших(бал нижче 50).
const LOW_SCORE = 50;
const HIGH_SCORE = 80;
const disciples = [
    { name: "Манго", score: 83 },
    { name: "Полі", score: 59 },
    { name: "Аякс", score: 37 },
    { name: "Ківі", score: 94 },
    { name: "Х'юстон", score: 64 },
];
console.log("disciples:", disciples);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

const best = disciples.filter(student => student.score >= HIGH_SCORE);
console.log("Кращі учні:", best); //! Масив об'єктів з іменами Манго і Ківі

//todo: В колбек-функції зручно деструктуризувати властивості об'єкта:
const average = disciples.filter(
    ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
);
console.log("Середні учні:", average); //! Масив об'єктів з іменами Полі і Х'юстон

const worst = disciples.filter(student => student.score < LOW_SCORE);
console.log("Гірші учні:", worst); //! Масив з одним об'єктом Аякс
console.log("----------------------------------------------------------------------------------------------");

//! Метод find()
console.warn("Синтаксис методу find():");
//? ✴️ Якщо метод filter(callback) використовується
//? для пошуку всіх елементів, що задовольняють умову,
//? то метод find(callback) дозволяє
//? знайти і повернути перший відповідний елемент,
//? після чого перебирання масиву припиняється.
//? Тобто він шукає до першого збігу.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає перший елемент, що задовольняє умову,
//?    тобто коли колбек повертає true.
//? 🔸 Якщо жоден елемент не задовольнив умову, 
//?    тобто для всіх елементів колбек повернув false, 
//?    метод повертає undefined.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.find((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода find():");
//? ✴️ Метод find() використовується для одного завдання
//? - пошуку елемента за унікальним значенням властивості.
//? ✳️ Наприклад, 
//? пошук користувача за поштою, 
//? автомобіля - за серійним номером, 
//? книги - за назвою тощо.
const colorPickerOptions1 = [
    { label: "red", color: "#F44336" },
    { label: "green", color: "#4CAF50" },
    { label: "blue", color: "#2196F3" },
    { label: "pink", color: "#E91E63" },
    { label: "indigo", color: "#3F51B5" },
];
console.log("colorPickerOptions1:", colorPickerOptions1);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

console.log('Пошук за позначкою "blue:"', colorPickerOptions1.find(option => option.label === "blue")); //! { label: 'blue', color: '#2196F3' }
console.log('Пошук за позначкою "pink:"', colorPickerOptions1.find(option => option.label === "pink")); //! { label: 'pink', color: '#E91E63' }
console.log('Пошук за позначкою "white:"', colorPickerOptions1.find(option => option.label === "white")); //! undefined
console.log("-------------------------------------------------------------------------");


//! Метод findIndex()
console.warn("Синтаксис методу findIndex():");
//? ✴️ Метод findIndex(callback)
//? - це сучасна заміна методу indexOf().
//? Дозволяє виконувати пошук за складнішими умовами,
//? ніж просто рівність.
//? Використовується як для пошуку
//? у масиві примітивів, так і в масиві об'єктів.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає індекс першого елемента, що задовольняє умову,
//?    тобто коли колбек повертає true.
//? 🔸 Якщо жоден елемент не задовольнив умову,
//?    тобто для всіх елементів колбек повернув false,
//?    метод повертає -1.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.findIndex((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода findIndex():");
//? ✳️ Приклад-1:
const colorPickerOptions2 = [
    { label: "red", color: "#F44336" },
    { label: "green", color: "#4CAF50" },
    { label: "blue", color: "#2196F3" },
    { label: "pink", color: "#E91E63" },
    { label: "indigo", color: "#3F51B5" },
];
console.log("colorPickerOptions2:", colorPickerOptions2);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

console.log('Індекс мітки "blue:"', colorPickerOptions2.findIndex(option => option.label === "blue")); //! 2
console.log('Індекс мітки "pink:"', colorPickerOptions2.findIndex(option => option.label === "pink")); //! 3
console.log('Індекс мітки "white:"', colorPickerOptions2.findIndex(option => option.label === "white")); //! -1
console.log("-------------------------------------------------------------------------");

//! Метод every()
console.warn("Синтаксис методу every():");
//? ✴️ Перевіряє, чи проходять ВСІ елементи масиву
//? тест колбек-функції.
//? Повертає true або false.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає true, якщо ВСІ елементи масиву задовольняють умову.
//? 🔸 Повертає false, якщо хоча б один елемент масиву не задовольняє умову.
//? 🔸 Перебирання масиву припиняється, якщо колбек повертає false.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.every((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода every():");
//? ✳️ Приклад-1:
//todo: УСІ елементи більші або дорівнюють нулю? - ТАК
console.log("УСІ елементи [1, 2, 3, 4, 5] більші або дорівнюють нулю? -", [1, 2, 3, 4, 5].every(value => value >= 0)); //! true


//todo:  УСІ елементи більші або дорівнюють нулю? - НІ
console.log("УСІ елементи [1, 2, 3, -10, 4, 5] більші або дорівнюють нулю? -", [1, 2, 3, -10, 4, 5].every(value => value >= 0)); //! false
console.log("-----------------------------------------------------------------------------------------");


//! Метод some()
console.warn("Синтаксис методу some():");
//? ✴️ Перевіряє, чи проходить хоча б ОДИН елемент масиву
//?  тест колбек-функції.
//? Повертає true або false.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає true, якщо хоча б ОДИН елемент масиву задовольняє умову.
//? 🔸 Повертає false, якщо жоден елемент масиву не задовольняє умову.
//? 🔸 Перебирання масиву припиняється, якщо колбек повертає false.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.some((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода some():");
//? ✳️ Приклад-2:
//todo:  Чи є хоча б один елемент, що більший або дорівнює нулю? - ТАК
console.log("Чи є хоча б один елемент з [1, 2, 3, 4, 5], що більший або дорівнює нулю? -", [1, 2, 3, 4, 5].some(value => value >= 0)); //! true

//todo:  Чи є хоча б один елемент, що більший або дорівнює нулю? - ТАК
console.log("Чи є хоча б один елемент з [-7, -20, 3, -10, -14], що більший або дорівнює нулю? -", [-7, -20, 3, -10, -14].some(value => value >= 0)); //! true

//todo:  Чи є хоча б один елемент, що менший нуля? - НІ
console.log("Чи є хоча б один елемент з [1, 2, 3, 4, 5], що менший нуля? -", [1, 2, 3, 4, 5].some(value => value < 0)); //! false

//todo:  Чи є хоча б один елемент, що менший нуля? - ТАК
console.log("Чи є хоча б один елемент з [1, 2, 3, -10, 4, 5], що менший нуля? -", [1, 2, 3, -10, 4, 5].some(value => value < 0)); //! true
console.log("-----------------------------------------------------------------------------------------");
